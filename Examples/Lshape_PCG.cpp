#include <Eigen/Sparse>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <stdexcept>

#include "BoundaryMesh.hpp"
#include "L2ProjectionToP1.hpp"
#include "L2WithP1Basis.hpp"
#include "LshapeMesh.hpp"
#include "NeumannTraceInterpolation.hpp"
#include "buildHypsingStabilization.hpp"
#include "buildK.hpp"
#include "buildM.hpp"
#include "buildV.hpp"
#include "buildW.hpp"
#include "evaluateK.hpp"
#include "evaluateV.hpp"
#include "gaussQuadrature.h"
#include "geometry.hpp"
#include "potentials.hpp"

int main(int, char **) {
  int N = 6;
  Eigen::VectorXd hdata(N), err_data(N);
  Eigen::VectorXi its(N), cits(N);
  std::cout << std::setw(10) << "level" << std::setw(25)
            << "#its (no conditioning)" << std::setw(25) << "#its (conditioned)"
            << std::endl;
  for (int k = 0; k < N; ++k) {
    BoundaryMesh mesh = createLshapeMesh(k + 1);

    // Single layer Galerkin matrix
    Eigen::MatrixXd V;
    computeV(V, mesh, 0);

    // Hypersingular Galerkin matrix (Unstabilized)
    Eigen::MatrixXd Wmat;
    computeW(Wmat, mesh, 0);
    // Stabilization for W
    Eigen::MatrixXd WmatStab;
    buildHypsingStabilization(WmatStab, mesh);
    // Adding the stabilization to WmatStab
    WmatStab += Wmat;

    // Double layer Galerkin matrix
    Eigen::MatrixXd K;
    computeK(K, mesh, 0);

    // Mass matrices
    // Test space (rows) = P1, Trial space (columns) = P1
    Eigen::SparseMatrix<double> M11(mesh.numVertices(), mesh.numVertices());
    computeM11(M11, mesh);
    // Test space (rows) = P0, Trial space (columns) = P1
    Eigen::SparseMatrix<double> M01(mesh.numElements(), mesh.numVertices());
    computeM01(M01, mesh);

    // Copied from Lshape_PCG.m
    // Get the uniformly refined mesh
    auto pair_output = mesh.uniformRefine();

    // Uniformly refined mesh (Barycentric refinement for segment mesh)
    BoundaryMesh refinedMesh = pair_output.first;
    // Father2son relation
    Eigen::MatrixXi father2son = pair_output.second;

    // Single layer galerkin matrix for the refined mesh
    Eigen::MatrixXd V_fine;
    computeV(V_fine, refinedMesh, 0);

    Eigen::MatrixXd V_dual =
        Eigen::MatrixXd::Zero(mesh.numElements(), mesh.numElements());

    for (int i = 0; i < mesh.numElements(); ++i) {
      int i_node_1 = mesh.getElementVertex(i, 0);
      int i_node_2 = mesh.getElementVertex(i, 1);

      int i_elem_1 = father2son(i, 0);
      int i_elem_2 = father2son(i, 1);

      for (int j = 0; j < mesh.numElements(); ++j) {
        int j_node_1 = mesh.getElementVertex(j, 0);
        int j_node_2 = mesh.getElementVertex(j, 1);

        int j_elem_1 = father2son(j, 0);
        int j_elem_2 = father2son(j, 1);

        V_dual(i_node_1, j_node_1) += V_fine(i_elem_1, j_elem_1);
        V_dual(i_node_1, j_node_2) += V_fine(i_elem_1, j_elem_2);
        V_dual(i_node_2, j_node_1) += V_fine(i_elem_2, j_elem_1);
        V_dual(i_node_2, j_node_2) += V_fine(i_elem_2, j_elem_2);
      }
    }

    Eigen::MatrixXd M =
        Eigen::MatrixXd::Zero(mesh.numElements(), mesh.numElements());
    for (int i = 0; i < mesh.numElements(); ++i) {
      int i_node_1 = mesh.getElementVertex(i, 0);
      int i_node_2 = mesh.getElementVertex(i, 1);

      M(i_node_1, i_node_1) += 3. / 8.;
      M(i_node_2, i_node_2) += 3. / 8.;
      M(i_node_1, i_node_2) += 1. / 8.;
      M(i_node_2, i_node_1) += 1. / 8.;
    }

    // L2 projection of Dirichlet data
    Eigen::VectorXd g_projected = L2ProjectionToP1(u, mesh);

    Eigen::VectorXd neumann_trace = NeumannTraceInterpolation(gradu, mesh);
    Eigen::VectorXd rhs =
        0.5 * M01.transpose() * neumann_trace - K.transpose() * neumann_trace;

    // Solving using CG on the stabilized W matrix generated by CppHilbert
    Eigen::VectorXd dirichlet_sol = WmatStab.lu().solve(rhs);

    Eigen::ConjugateGradient<Eigen::MatrixXd> cg;
    cg.compute(WmatStab);
    Eigen::VectorXd dirichlet_sol_cg = cg.solve(rhs);

    its(k) = cg.iterations();

    // Calderon preconditioning
    Eigen::MatrixXd Minv = M.inverse();
    Eigen::MatrixXd preconditioner = Minv * V_dual * Minv;
    Eigen::MatrixXd conditionedLHS = preconditioner * WmatStab;
    Eigen::VectorXd conditionedRHS = preconditioner * rhs;
    Eigen::ConjugateGradient<Eigen::MatrixXd> cgpc;
    cgpc.compute(conditionedLHS);
    Eigen::VectorXd dirichlet_sol_cg_pc = cgpc.solve(conditionedRHS);

    cits(k) = cgpc.iterations();

    std::cout << std::setw(10) << k << std::setw(25) << its(k) << std::setw(25)
              << cits(k) << std::endl;
  }

  return 0;
}
